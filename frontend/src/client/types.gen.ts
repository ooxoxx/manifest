// This file is auto-generated by @hey-api/openapi-ts

/**
 * Annotation status enum.
 */
export type AnnotationStatus = 'none' | 'linked' | 'conflict' | 'error';

/**
 * Request for batch tagging samples.
 */
export type BatchTagRequest = {
    sample_ids: Array<(string)>;
    tag_ids: Array<(string)>;
};

export type Body_login_login_access_token = {
    grant_type?: (string | null);
    username: string;
    password: string;
    scope?: string;
    client_id?: (string | null);
    client_secret?: (string | null);
};

export type Body_samples_import_samples = {
    file: (Blob | File);
    minio_instance_id: string;
    bucket?: (string | null);
    validate_files?: boolean;
};

export type Body_samples_preview_import_csv = {
    file: (Blob | File);
};

/**
 * Statistics for a single class.
 */
export type ClassStat = {
    name: string;
    count: number;
};

/**
 * Response for filter class stats.
 */
export type ClassStatsResponse = {
    classes: Array<ClassStat>;
    total_samples: number;
    total_objects: number;
};

/**
 * CSV preview response for API.
 */
export type CSVPreviewResponse = {
    total_rows: number;
    columns: Array<(string)>;
    sample_rows: Array<{
        [key: string]: unknown;
    }>;
    has_tags_column: boolean;
    image_count: number;
    annotation_count: number;
};

/**
 * Daily statistics.
 */
export type DailyStats = {
    date: string;
    count: number;
};

/**
 * Dashboard overview statistics.
 */
export type DashboardOverview = {
    total_samples: number;
    total_datasets: number;
    total_tags: number;
    total_minio_instances: number;
    samples_today: number;
    samples_this_week: number;
};

/**
 * Request for adding samples to existing dataset.
 */
export type DatasetAddSamplesRequest = {
    filters: FilterParams;
    sampling: SamplingConfig;
};

/**
 * Request for building a new dataset.
 */
export type DatasetBuildRequest = {
    name: string;
    description?: (string | null);
    filters: FilterParams;
    sampling: SamplingConfig;
};

/**
 * Properties to receive on dataset creation.
 */
export type DatasetCreate = {
    name: string;
    description?: (string | null);
    is_public?: boolean;
};

/**
 * Properties to return via API.
 */
export type DatasetPublic = {
    name: string;
    description?: (string | null);
    is_public?: boolean;
    id: string;
    owner_id: string;
    sample_count: number;
    created_at: string;
    updated_at: string;
};

/**
 * Request for adding/removing samples from dataset.
 */
export type DatasetSamplesRequest = {
    sample_ids: Array<(string)>;
};

/**
 * Paginated datasets response.
 */
export type DatasetsPublic = {
    data: Array<DatasetPublic>;
    count: number;
};

/**
 * Properties to receive on dataset update.
 */
export type DatasetUpdate = {
    name?: (string | null);
    description?: (string | null);
    is_public?: (boolean | null);
};

/**
 * Parameters for filtering samples.
 */
export type FilterParams = {
    tag_filter?: (Array<Array<(string)>> | null);
    tags_include?: (Array<(string)> | null);
    tags_exclude?: (Array<(string)> | null);
    date_from?: (string | null);
    date_to?: (string | null);
    annotation_classes?: (Array<(string)> | null);
    object_count_min?: (number | null);
    object_count_max?: (number | null);
    annotation_status?: (AnnotationStatus | null);
};

export type HTTPValidationError = {
    detail?: Array<ValidationError>;
};

/**
 * Import task response for API.
 */
export type ImportTaskPublic = {
    id: string;
    status: ImportTaskStatus;
    total_rows: number;
    progress: number;
    created: number;
    skipped: number;
    errors: number;
    annotations_linked: number;
    tags_created: number;
    error_details: (Array<unknown> | null);
    created_at: string;
    updated_at: string;
    completed_at: (string | null);
};

/**
 * Import task status enum.
 */
export type ImportTaskStatus = 'pending' | 'running' | 'completed' | 'failed';

export type Message = {
    message: string;
};

/**
 * Properties to receive on MinIO instance creation.
 */
export type MinIOInstanceCreate = {
    name: string;
    endpoint: string;
    secure?: boolean;
    description?: (string | null);
    is_active?: boolean;
    access_key: string;
    secret_key: string;
};

/**
 * Properties to return via API.
 */
export type MinIOInstancePublic = {
    name: string;
    endpoint: string;
    secure?: boolean;
    description?: (string | null);
    is_active?: boolean;
    id: string;
    owner_id: string;
    created_at: string;
    updated_at: string;
};

/**
 * Paginated MinIO instances response.
 */
export type MinIOInstancesPublic = {
    data: Array<MinIOInstancePublic>;
    count: number;
};

/**
 * Properties to receive on MinIO instance update.
 */
export type MinIOInstanceUpdate = {
    name?: (string | null);
    endpoint?: (string | null);
    secure?: (boolean | null);
    description?: (string | null);
    is_active?: (boolean | null);
    access_key?: (string | null);
    secret_key?: (string | null);
};

export type NewPassword = {
    token: string;
    new_password: string;
};

export type PrivateUserCreate = {
    email: string;
    password: string;
    full_name: string;
    is_verified?: boolean;
};

/**
 * Sample history action enum.
 */
export type SampleHistoryAction = 'created' | 'updated' | 'deleted' | 'tagged' | 'untagged' | 'added_to_dataset' | 'removed_from_dataset' | 'annotation_linked' | 'annotation_conflict' | 'annotation_removed';

/**
 * Properties to return via API.
 */
export type SampleHistoryPublic = {
    id: string;
    sample_id: string;
    action: SampleHistoryAction;
    details: ({
    [key: string]: unknown;
} | null);
    created_at: string;
};

/**
 * Response for paginated sample list with infinite scroll support.
 */
export type SampleListResponse = {
    items: Array<SamplePublic>;
    total: number;
    has_more: boolean;
};

/**
 * Annotation data for sample preview.
 */
export type SamplePreviewAnnotation = {
    objects?: (Array<{
    [key: string]: unknown;
}> | null);
    class_counts?: ({
    [key: string]: (number);
} | null);
    image_width?: (number | null);
    image_height?: (number | null);
};

/**
 * Response for sample preview API.
 */
export type SamplePreviewResponse = {
    presigned_url: string;
    expires_in: number;
    annotation?: (SamplePreviewAnnotation | null);
    tags?: Array<TagPublic>;
    sample: SamplePublic;
};

/**
 * Properties to return via API.
 */
export type SamplePublic = {
    object_key: string;
    bucket: string;
    file_name: string;
    file_size?: number;
    content_type?: (string | null);
    etag?: (string | null);
    extra_data?: ({
    [key: string]: unknown;
} | null);
    file_hash?: (string | null);
    file_stem?: (string | null);
    annotation_key?: (string | null);
    annotation_hash?: (string | null);
    annotation_status?: AnnotationStatus;
    id: string;
    minio_instance_id: string;
    owner_id: string;
    status: SampleStatus;
    source: SampleSource;
    created_at: string;
    updated_at: string;
};

/**
 * Sample source enum.
 */
export type SampleSource = 'webhook' | 'sync' | 'import' | 'manual';

/**
 * Paginated samples response.
 */
export type SamplesPublic = {
    data: Array<SamplePublic>;
    count: number;
};

/**
 * Sample status enum.
 */
export type SampleStatus = 'active' | 'deleted' | 'archived';

/**
 * Thumbnail data for a single sample.
 */
export type SampleThumbnail = {
    id: string;
    presigned_url: string;
    file_name: string;
    file_size: number;
    created_at: string;
    annotation_status: AnnotationStatus;
    class_counts?: ({
    [key: string]: (number);
} | null);
};

/**
 * Request for batch sample thumbnails.
 */
export type SampleThumbnailsRequest = {
    sample_ids: Array<(string)>;
};

/**
 * Sample with tags for detailed view.
 */
export type SampleWithTags = {
    object_key: string;
    bucket: string;
    file_name: string;
    file_size?: number;
    content_type?: (string | null);
    etag?: (string | null);
    extra_data?: ({
    [key: string]: unknown;
} | null);
    file_hash?: (string | null);
    file_stem?: (string | null);
    annotation_key?: (string | null);
    annotation_hash?: (string | null);
    annotation_status?: AnnotationStatus;
    id: string;
    minio_instance_id: string;
    owner_id: string;
    status: SampleStatus;
    source: SampleSource;
    created_at: string;
    updated_at: string;
    tags?: Array<TagPublic>;
};

/**
 * Configuration for sampling strategy.
 */
export type SamplingConfig = {
    mode?: SamplingMode;
    count?: (number | null);
    class_targets?: ({
    [key: string]: (number);
} | null);
    seed?: (number | null);
};

/**
 * Sampling mode for dataset building.
 */
export type SamplingMode = 'all' | 'random' | 'class_targets';

/**
 * System tag type for automatic tagging.
 */
export type SystemTagType = 'file_type' | 'source' | 'annotation_status' | 'storage_instance';

/**
 * Tag category for semantic grouping.
 */
export type TagCategory = 'system' | 'business' | 'user';

/**
 * Properties to receive on tag creation.
 */
export type TagCreate = {
    name: string;
    color?: (string | null);
    description?: (string | null);
    category?: TagCategory;
    parent_id?: (string | null);
};

/**
 * Tag distribution statistics.
 */
export type TagDistribution = {
    tag_id: string;
    tag_name: string;
    count: number;
};

/**
 * Properties to receive on tagging rule creation.
 */
export type TaggingRuleCreate = {
    name: string;
    description?: (string | null);
    rule_type: TaggingRuleType;
    pattern: string;
    is_active?: boolean;
    auto_execute?: boolean;
    tag_ids: Array<(string)>;
};

/**
 * Result of executing a tagging rule.
 */
export type TaggingRuleExecuteResult = {
    matched: number;
    tagged: number;
    skipped: number;
};

/**
 * Result of previewing a tagging rule.
 */
export type TaggingRulePreviewResult = {
    total_matched: number;
    samples: Array<SamplePublic>;
};

/**
 * Properties to return via API.
 */
export type TaggingRulePublic = {
    name: string;
    description?: (string | null);
    rule_type: TaggingRuleType;
    pattern: string;
    is_active?: boolean;
    auto_execute?: boolean;
    id: string;
    tag_ids: Array<(string)>;
    owner_id: string;
    created_at: string;
    updated_at: string;
};

/**
 * Paginated tagging rules response.
 */
export type TaggingRulesPublic = {
    data: Array<TaggingRulePublic>;
    count: number;
};

/**
 * Tagging rule type for batch tagging.
 */
export type TaggingRuleType = 'regex_filename' | 'regex_path' | 'file_extension' | 'bucket' | 'content_type';

/**
 * Properties to receive on tagging rule update.
 */
export type TaggingRuleUpdate = {
    name?: (string | null);
    description?: (string | null);
    rule_type?: (TaggingRuleType | null);
    pattern?: (string | null);
    tag_ids?: (Array<(string)> | null);
    is_active?: (boolean | null);
    auto_execute?: (boolean | null);
};

/**
 * Properties to return via API.
 */
export type TagPublic = {
    name: string;
    color?: (string | null);
    description?: (string | null);
    category?: TagCategory;
    id: string;
    parent_id: (string | null);
    owner_id: (string | null);
    is_system_managed: boolean;
    business_code: (string | null);
    level: number;
    full_path: (string | null);
    system_tag_type: (SystemTagType | null);
    created_at: string;
    updated_at: string;
};

/**
 * Tags grouped by category.
 */
export type TagsByCategoryResponse = {
    system?: Array<TagPublic>;
    business?: Array<TagPublic>;
    user?: Array<TagPublic>;
};

/**
 * Paginated tags response.
 */
export type TagsPublic = {
    data: Array<TagPublic>;
    count: number;
};

/**
 * Properties to receive on tag update.
 */
export type TagUpdate = {
    name?: (string | null);
    color?: (string | null);
    description?: (string | null);
    category?: (TagCategory | null);
    parent_id?: (string | null);
};

/**
 * Tag with children for tree structure.
 */
export type TagWithChildren = {
    name: string;
    color?: (string | null);
    description?: (string | null);
    category?: TagCategory;
    id: string;
    parent_id: (string | null);
    owner_id: (string | null);
    is_system_managed: boolean;
    business_code: (string | null);
    level: number;
    full_path: (string | null);
    system_tag_type: (SystemTagType | null);
    created_at: string;
    updated_at: string;
    children?: Array<TagWithChildren>;
};

export type Token = {
    access_token: string;
    token_type?: string;
};

export type UpdatePassword = {
    current_password: string;
    new_password: string;
};

export type UserCreate = {
    email: string;
    is_active?: boolean;
    is_superuser?: boolean;
    full_name?: (string | null);
    password: string;
};

export type UserPublic = {
    email: string;
    is_active?: boolean;
    is_superuser?: boolean;
    full_name?: (string | null);
    id: string;
};

export type UserRegister = {
    email: string;
    password: string;
    full_name?: (string | null);
};

export type UsersPublic = {
    data: Array<UserPublic>;
    count: number;
};

export type UserUpdate = {
    email?: (string | null);
    is_active?: boolean;
    is_superuser?: boolean;
    full_name?: (string | null);
    password?: (string | null);
};

export type UserUpdateMe = {
    full_name?: (string | null);
    email?: (string | null);
};

export type ValidationError = {
    loc: Array<(string | number)>;
    msg: string;
    type: string;
};

/**
 * Properties to receive on watched path creation.
 */
export type WatchedPathCreate = {
    bucket: string;
    prefix?: string;
    description?: (string | null);
    is_active?: boolean;
    minio_instance_id: string;
};

/**
 * Properties to return via API.
 */
export type WatchedPathPublic = {
    bucket: string;
    prefix?: string;
    description?: (string | null);
    is_active?: boolean;
    id: string;
    minio_instance_id: string;
    last_sync_at: (string | null);
    created_at: string;
    updated_at: string;
};

/**
 * Paginated watched paths response.
 */
export type WatchedPathsPublic = {
    data: Array<WatchedPathPublic>;
    count: number;
};

/**
 * Properties to receive on watched path update.
 */
export type WatchedPathUpdate = {
    bucket?: (string | null);
    prefix?: (string | null);
    description?: (string | null);
    is_active?: (boolean | null);
};

export type DashboardGetDashboardOverviewResponse = (DashboardOverview);

export type DashboardGetDailyStatsData = {
    days?: number;
};

export type DashboardGetDailyStatsResponse = (Array<DailyStats>);

export type DashboardGetTagDistributionData = {
    limit?: number;
};

export type DashboardGetTagDistributionResponse = (Array<TagDistribution>);

export type DatasetsReadDatasetsData = {
    limit?: number;
    skip?: number;
};

export type DatasetsReadDatasetsResponse = (DatasetsPublic);

export type DatasetsCreateDatasetData = {
    requestBody: DatasetCreate;
};

export type DatasetsCreateDatasetResponse = (DatasetPublic);

export type DatasetsFilterPreviewData = {
    limit?: number;
    requestBody: FilterParams;
    skip?: number;
};

export type DatasetsFilterPreviewResponse = ({
    [key: string]: unknown;
});

export type DatasetsFilterClassStatsData = {
    requestBody: FilterParams;
};

export type DatasetsFilterClassStatsResponse = (ClassStatsResponse);

export type DatasetsBuildNewDatasetData = {
    requestBody: DatasetBuildRequest;
};

export type DatasetsBuildNewDatasetResponse = ({
    [key: string]: unknown;
});

export type DatasetsAddFilteredSamplesToDatasetData = {
    datasetId: string;
    requestBody: DatasetAddSamplesRequest;
};

export type DatasetsAddFilteredSamplesToDatasetResponse = ({
    [key: string]: unknown;
});

export type DatasetsReadDatasetData = {
    id: string;
};

export type DatasetsReadDatasetResponse = (DatasetPublic);

export type DatasetsUpdateDatasetData = {
    id: string;
    requestBody: DatasetUpdate;
};

export type DatasetsUpdateDatasetResponse = (DatasetPublic);

export type DatasetsDeleteDatasetData = {
    id: string;
};

export type DatasetsDeleteDatasetResponse = (Message);

export type DatasetsGetDatasetClassStatsData = {
    id: string;
};

export type DatasetsGetDatasetClassStatsResponse = (ClassStatsResponse);

export type DatasetsGetDatasetSamplesData = {
    classFilter?: (string | null);
    id: string;
    limit?: number;
    skip?: number;
};

export type DatasetsGetDatasetSamplesResponse = (SamplesPublic);

export type DatasetsAddSamplesToDatasetData = {
    id: string;
    requestBody: DatasetSamplesRequest;
};

export type DatasetsAddSamplesToDatasetResponse = ({
    [key: string]: unknown;
});

export type DatasetsRemoveSamplesFromDatasetData = {
    id: string;
    requestBody: DatasetSamplesRequest;
};

export type DatasetsRemoveSamplesFromDatasetResponse = ({
    [key: string]: unknown;
});

export type DatasetsBuildDatasetData = {
    id: string;
    requestBody: DatasetBuildRequest;
};

export type DatasetsBuildDatasetResponse = ({
    [key: string]: unknown;
});

export type LoginLoginAccessTokenData = {
    formData: Body_login_login_access_token;
};

export type LoginLoginAccessTokenResponse = (Token);

export type LoginTestTokenResponse = (UserPublic);

export type LoginRecoverPasswordData = {
    email: string;
};

export type LoginRecoverPasswordResponse = (Message);

export type LoginResetPasswordData = {
    requestBody: NewPassword;
};

export type LoginResetPasswordResponse = (Message);

export type LoginRecoverPasswordHtmlContentData = {
    email: string;
};

export type LoginRecoverPasswordHtmlContentResponse = (string);

export type MinioInstancesReadMinioInstancesData = {
    limit?: number;
    skip?: number;
};

export type MinioInstancesReadMinioInstancesResponse = (MinIOInstancesPublic);

export type MinioInstancesCreateMinioInstanceEndpointData = {
    requestBody: MinIOInstanceCreate;
};

export type MinioInstancesCreateMinioInstanceEndpointResponse = (MinIOInstancePublic);

export type MinioInstancesReadMinioInstanceData = {
    id: string;
};

export type MinioInstancesReadMinioInstanceResponse = (MinIOInstancePublic);

export type MinioInstancesUpdateMinioInstanceEndpointData = {
    id: string;
    requestBody: MinIOInstanceUpdate;
};

export type MinioInstancesUpdateMinioInstanceEndpointResponse = (MinIOInstancePublic);

export type MinioInstancesDeleteMinioInstanceData = {
    id: string;
};

export type MinioInstancesDeleteMinioInstanceResponse = (Message);

export type MinioInstancesTestMinioConnectionData = {
    id: string;
};

export type MinioInstancesTestMinioConnectionResponse = ({
    [key: string]: unknown;
});

export type MinioInstancesListMinioBucketsData = {
    id: string;
};

export type MinioInstancesListMinioBucketsResponse = ({
    [key: string]: unknown;
});

export type PrivateCreateUserData = {
    requestBody: PrivateUserCreate;
};

export type PrivateCreateUserResponse = (UserPublic);

export type SamplesReadSamplesData = {
    annotationStatus?: (AnnotationStatus | null);
    bucket?: (string | null);
    dateFrom?: (string | null);
    dateTo?: (string | null);
    limit?: number;
    minioInstanceId?: (string | null);
    search?: (string | null);
    skip?: number;
    sort?: string;
    status?: (SampleStatus | null);
    tagFilter?: (string | null);
    tagId?: (string | null);
};

export type SamplesReadSamplesResponse = (SampleListResponse);

export type SamplesGetSampleThumbnailsData = {
    requestBody: SampleThumbnailsRequest;
};

export type SamplesGetSampleThumbnailsResponse = (Array<SampleThumbnail>);

export type SamplesListImportTasksData = {
    limit?: number;
    skip?: number;
};

export type SamplesListImportTasksResponse = (Array<ImportTaskPublic>);

export type SamplesImportSamplesData = {
    formData: Body_samples_import_samples;
};

export type SamplesImportSamplesResponse = (ImportTaskPublic);

export type SamplesGetImportStatusData = {
    taskId: string;
};

export type SamplesGetImportStatusResponse = (ImportTaskPublic);

export type SamplesPreviewImportCsvData = {
    formData: Body_samples_preview_import_csv;
};

export type SamplesPreviewImportCsvResponse = (CSVPreviewResponse);

export type SamplesReadSampleData = {
    id: string;
};

export type SamplesReadSampleResponse = (SampleWithTags);

export type SamplesDeleteSampleData = {
    id: string;
};

export type SamplesDeleteSampleResponse = (Message);

export type SamplesGetSamplePreviewUrlData = {
    expiresHours?: number;
    id: string;
};

export type SamplesGetSamplePreviewUrlResponse = ({
    [key: string]: unknown;
});

export type SamplesGetSamplePreviewData = {
    expiresHours?: number;
    id: string;
};

export type SamplesGetSamplePreviewResponse = (SamplePreviewResponse);

export type SamplesGetSampleHistoryData = {
    id: string;
};

export type SamplesGetSampleHistoryResponse = (Array<SampleHistoryPublic>);

export type SamplesBatchTagSamplesData = {
    requestBody: BatchTagRequest;
};

export type SamplesBatchTagSamplesResponse = ({
    [key: string]: unknown;
});

export type TaggingRulesReadTaggingRulesData = {
    limit?: number;
    skip?: number;
};

export type TaggingRulesReadTaggingRulesResponse = (TaggingRulesPublic);

export type TaggingRulesCreateTaggingRuleData = {
    requestBody: TaggingRuleCreate;
};

export type TaggingRulesCreateTaggingRuleResponse = (TaggingRulePublic);

export type TaggingRulesReadTaggingRuleData = {
    id: string;
};

export type TaggingRulesReadTaggingRuleResponse = (TaggingRulePublic);

export type TaggingRulesUpdateTaggingRuleData = {
    id: string;
    requestBody: TaggingRuleUpdate;
};

export type TaggingRulesUpdateTaggingRuleResponse = (TaggingRulePublic);

export type TaggingRulesDeleteTaggingRuleData = {
    id: string;
};

export type TaggingRulesDeleteTaggingRuleResponse = (Message);

export type TaggingRulesExecuteTaggingRuleData = {
    dryRun?: boolean;
    id: string;
};

export type TaggingRulesExecuteTaggingRuleResponse = (TaggingRuleExecuteResult);

export type TaggingRulesPreviewTaggingRuleData = {
    id: string;
    limit?: number;
};

export type TaggingRulesPreviewTaggingRuleResponse = (TaggingRulePreviewResult);

export type TagsReadTagsData = {
    category?: (TagCategory | null);
    limit?: number;
    skip?: number;
};

export type TagsReadTagsResponse = (TagsPublic);

export type TagsCreateTagData = {
    requestBody: TagCreate;
};

export type TagsCreateTagResponse = (TagPublic);

export type TagsGetTagTreeResponse = (Array<TagWithChildren>);

export type TagsGetTagsByCategoryResponse = (TagsByCategoryResponse);

export type TagsUpdateTagData = {
    id: string;
    requestBody: TagUpdate;
};

export type TagsUpdateTagResponse = (TagPublic);

export type TagsDeleteTagData = {
    id: string;
};

export type TagsDeleteTagResponse = (Message);

export type TagsGetBusinessTagTreeResponse = (unknown);

export type TagsSearchBusinessTagData = {
    limit?: number;
    q: string;
};

export type TagsSearchBusinessTagResponse = (Array<TagPublic>);

export type UsersReadUsersData = {
    limit?: number;
    skip?: number;
};

export type UsersReadUsersResponse = (UsersPublic);

export type UsersCreateUserData = {
    requestBody: UserCreate;
};

export type UsersCreateUserResponse = (UserPublic);

export type UsersReadUserMeResponse = (UserPublic);

export type UsersDeleteUserMeResponse = (Message);

export type UsersUpdateUserMeData = {
    requestBody: UserUpdateMe;
};

export type UsersUpdateUserMeResponse = (UserPublic);

export type UsersUpdatePasswordMeData = {
    requestBody: UpdatePassword;
};

export type UsersUpdatePasswordMeResponse = (Message);

export type UsersRegisterUserData = {
    requestBody: UserRegister;
};

export type UsersRegisterUserResponse = (UserPublic);

export type UsersReadUserByIdData = {
    userId: string;
};

export type UsersReadUserByIdResponse = (UserPublic);

export type UsersUpdateUserData = {
    requestBody: UserUpdate;
    userId: string;
};

export type UsersUpdateUserResponse = (UserPublic);

export type UsersDeleteUserData = {
    userId: string;
};

export type UsersDeleteUserResponse = (Message);

export type UtilsTestEmailData = {
    emailTo: string;
};

export type UtilsTestEmailResponse = (Message);

export type UtilsHealthCheckResponse = (boolean);

export type WatchedPathsReadWatchedPathsData = {
    limit?: number;
    minioInstanceId?: (string | null);
    skip?: number;
};

export type WatchedPathsReadWatchedPathsResponse = (WatchedPathsPublic);

export type WatchedPathsCreateWatchedPathData = {
    requestBody: WatchedPathCreate;
};

export type WatchedPathsCreateWatchedPathResponse = (WatchedPathPublic);

export type WatchedPathsUpdateWatchedPathData = {
    id: string;
    requestBody: WatchedPathUpdate;
};

export type WatchedPathsUpdateWatchedPathResponse = (WatchedPathPublic);

export type WatchedPathsDeleteWatchedPathData = {
    id: string;
};

export type WatchedPathsDeleteWatchedPathResponse = (Message);

export type WatchedPathsSyncWatchedPathData = {
    id: string;
};

export type WatchedPathsSyncWatchedPathResponse = ({
    [key: string]: unknown;
});

export type WebhooksReceiveMinioWebhookData = {
    instanceId: string;
};

export type WebhooksReceiveMinioWebhookResponse = ({
    [key: string]: unknown;
});